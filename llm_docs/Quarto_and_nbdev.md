Quarto and nbdev: Tools for Notebook-Based Publishing and Development

Quarto and nbdev are complementary tools built around Jupyter notebooks, but they serve different purposes. Quarto is a general-purpose publishing system (by Posit/RStudio) that converts notebooks or markdown into well-formatted documents (HTML, PDF, Word, slides, websites, etc.) ￼ ￼. By contrast, nbdev (by Fast.ai) is a development platform: it lets you write Python libraries entirely in notebooks and automatically generates clean .py modules, tests, documentation, and CI from them ￼ ￼. In practice, nbdev even uses Quarto under the hood to build docs, but adds features for packaging and testing. Below we outline each tool’s roles, setup, and workflows, then highlight their key differences.

Quarto – Publishing with Notebooks

Quarto is an open-source technical publishing system (built on Pandoc) that supports Jupyter, VS Code, RStudio, and other editors ￼.  It can take a notebook or Quarto-markdown file and render it to many formats – notably HTML, PDF, Word, ePub, slides, or complete websites and blogs ￼ ￼. Quarto’s strength is turning interactive analyses into polished documents.
	•	Installation: Download and install the Quarto CLI from quarto.org (or use Homebrew/apt, etc.).  You’ll also need a LaTeX engine (e.g. TinyTeX) if you want PDF output ￼.  Quarto integrates with JupyterLab and VS Code – for example, the Quarto VS Code extension provides syntax highlighting and Preview commands ￼.
	•	Using Quarto with Jupyter: Create or open a notebook (.ipynb) and add YAML front-matter at the top to set title, author, and output formats.  For example:

---
title: "My Analysis"
jupyter: python3
format:
  html: 
    code-fold: true
  pdf: 
    toc: true
---

Then run quarto render mydoc.ipynb in a terminal.  By default this produces HTML, but you can specify formats (e.g. --to pdf or --to html) ￼.  Quarto actually converts the notebook contents (markdown, code, outputs) into plain markdown and then uses Pandoc to generate the final document ￼ ￼.  For an interactive workflow, use quarto preview mydoc.ipynb – this opens a browser window that auto-updates as you edit and save ￼. In VS Code you can similarly press the Quarto Render or Preview buttons to see live output ￼.

	•	Publishing to HTML, PDF, etc.: Generating an HTML report or slide deck is as simple as quarto render report.qmd --to html.  For PDF, you must have a TeX installation; Quarto uses KOMA-Script classes by default (for high-quality typesetting) ￼.  (If PDF fails, ensure TinyTeX or similar is installed ￼.)  You can also output Word (--to docx) or reveal.js slides (--to revealjs), etc.  In practice, define the formats you want in YAML and just run quarto render to build all outputs.  The Pandoc engine means virtually any output is possible ￼.
	•	Websites and Blogs:  Quarto natively supports multi-page websites and blogs.  To create a site, use quarto create project website|book|blog mysite. For example, quarto create project blog myblog will scaffold a blog with a _quarto.yml config, an index.qmd home page, about.qmd, and a posts/ folder ￼.  Edit these files, then run quarto preview myblog/ or quarto render myblog/ to build the site.  New posts are added by creating a subfolder in posts/ with an index.qmd for that article; Quarto will automatically update the blog listing when you render ￼.  You can customize navigation, categories, drafts, and even “freeze” computational results.  (Setting freeze: true in a post’s YAML, for example, caches its output so it isn’t recomputed on each build ￼, which speeds up large sites.)
	•	Tips and Pitfalls:  Keep your YAML metadata valid – every Quarto document needs a --- header specifying title and formats.  Remember that Quarto uses Pandoc, so file extensions like .qmd (or .ipynb) are required.  When writing in VS Code, use the Quarto extension shortcuts (e.g. Ctrl+Shift+K to preview) ￼. Avoid using dynamic values (like date: today) in blog posts, as this will reorder your listings on each render ￼.  If you encounter rendering errors, try frequently “Restart & Run All” in your notebook to catch dependency or environment issues early.  And if PDF output is needed, install a TeX engine (quarto install tinytex ￼ is one convenient method). In general, Quarto is robust: “take a source document (notebook) and render it to a variety of output formats, including HTML, PDF, …” ￼.

nbdev – Notebook-Driven Development

nbdev is a notebook-driven development framework for Python.  Instead of using notebooks just for exploration, nbdev lets you develop an entire Python library within Jupyter ￼.  You write functions and classes in notebook cells (annotated with special directives), then nbdev automatically exports them to .py modules, runs tests, and builds documentation – all from the same notebook sources ￼ ￼.  The philosophy is literate programming: code, tests, and docs live together.
	•	Installation:  Install nbdev in the same Python environment you use for Jupyter (e.g. pip install nbdev or conda install -c fastai nbdev) ￼.  It requires Python ≥3.6 and works on macOS/Linux (Windows via WSL).  nbdev also uses Quarto for its docs site (nbdev even has an nbdev_install_quarto command to fetch Quarto automatically) ￼ ￼.
	•	Creating a project:  In a new or empty git repo, run nbdev_new.  This command asks a few questions (project name, authors, etc.) and creates files to bootstrap a package: a settings.ini config, nbs/ folder for notebooks, a modules/ folder for code, CI workflows, and Quarto docs config ￼.  For example, it will “streamline publishing to PyPI/conda, configure Quarto for docs, and set up GitHub Actions to test and deploy” your project ￼.  Check settings.ini (especially lib_name and paths) and push the repo.  By default nbdev assumes your Python package name matches the repo name (replacing - with _) ￼, but you can override that.
	•	Writing code and exporting:  Each notebook under nbs/ is a literate source file.  At the top of a notebook, use the #| default_exp modulename directive in a markdown cell to indicate which module its exported code belongs to.  Then in code cells, use #| export to mark definitions (functions, classes) that should go into the library.  When you run a notebook (for example by restarting the kernel and executing all cells – a recommended habit to ensure reproducibility ￼), nbdev will detect those directives.  At the end of your notebooks, include a hidden cell with:

#| hide
import nbdev; nbdev.nbdev_export()

This tells nbdev to generate .py modules under the modules/ (or your library) folder ￼.  In short, nbdev_export converts your annotated notebooks into pure Python files.  (You can also run nbdev_export manually at any time.)  After exporting, install your package in editable mode (pip install -e '.[dev]') to use it locally ￼.

	•	Testing:  One of nbdev’s superpowers is writing tests inline.  You can simply add code cells in your notebooks with assert statements or fastcore.test calls – these become your unit tests ￼.  For example, after defining def say_hello(): ..., you might write assert say_hello("World")=="Hello World!" in the next cell.  Running nbdev_test (or the combined nbdev_prepare) will execute all test cells across all notebooks (in parallel) and report failures ￼ ￼.  This ensures your documented examples stay correct.  The continuous integration workflows provided by nbdev also run these tests on each push, so broken notebooks are caught early.
	•	Documentation with Quarto:  nbdev generates documentation using Quarto.  By default, a home page and index are created from nbs/index.ipynb, and each notebook’s markdown and docstrings become pages.  You can preview the site locally with nbdev_preview, which uses Quarto to render and live-update the docs as you edit ￼.  When you push to GitHub, nbdev’s GitHub Actions build the Quarto site and publish it via GitHub Pages ￼ ￼.  You simply focus on writing rich markdown and code examples in your notebooks – nbdev+Quarto takes care of making it a polished website.  For instance, writing a Python example or output in a cell will show up in the docs, and show_doc(MyClass.method) in a notebook will generate API docs for that method.  The nbdev tutorial shows how adding examples and tests “right below your code” in the notebook automatically appears in the docs ￼.
	•	Best Practices & Tips:  Use nbdev_install_hooks early in a new repo.  This installs Jupyter/git hooks that clean metadata and outputs on save and use a custom git merge driver.  Concretely, each time you save a notebook it strips execution counts and other extraneous fields, and git conflicts are resolved at the cell level【23†L436-444】 ￼.  The result is that notebooks stay lightweight and mergeable – a major pain point in pure Jupyter workflows.  (Even nbdev’s docs note that using these hooks “fix broken notebooks due to git merge conflicts” and remove “unwanted metadata” automatically【23†L436-444】.)
Avoid mixing imports and other code in one cell, as nbdev warns against that: imports should be in their own cell so that documentation builds can run them without unintended side-effects ￼.  Always “Restart and Run All” before exporting to ensure cells execute in order ￼.  Remember to run nbdev_prepare before committing: this command bundles nbdev_export, nbdev_test, and nbdev_clean (plus it updates your README from the index) ￼.  It ensures your modules and docs are up-to-date and notebooks are clean. Finally, when you write new code, precede it with #| export so it is included in the package and docs; omit this tag if the cell is just exploratory or should not be exported.

Comparing Quarto and nbdev
	•	Purpose: Quarto is a publishing engine for documents and sites, whereas nbdev is a development framework for Python libraries.  Use Quarto when you need to turn analyses into reports, slides, or a blog.  Use nbdev when you want to build a library from notebooks, complete with tests and docs.
	•	Input/Output: Both accept notebooks as input, but Quarto’s output is content (HTML, PDF, etc.), while nbdev’s output is code and docs.  With nbdev, the code cells become your package’s Python modules, tests, and Markdown docs.  With Quarto, the code stays embedded in the final document (or blog site) for readers.
	•	Tools: Quarto works on its own (though nbdev uses it).  nbdev orchestrates Quarto plus its own CLI.  For example, both have a live preview: Quarto’s quarto preview, and nbdev’s nbdev_preview (which calls Quarto) ￼.
	•	Documentation: Quarto gives you polished formatting (themes, numbering, math, citations) out of the box ￼.  nbdev builds docs as well, but under the hood it is simply generating Quarto content from your notebooks.  Essentially, nbdev is like a specialized layer on top of Quarto for library development.
	•	Testing: Quarto itself has no testing features.  nbdev, in contrast, makes testing first-class: examples in notebooks double as tests, and nbdev_test will run them ￼.
	•	Collaboration: Quarto documents are static, so version control is like any text file.  Jupyter notebooks can be messy with diffs, but nbdev solves this with hooks ￼【23†L436-444】.  In practice, nbdev users report that writing docs and tests in one place has dramatically improved productivity ￼ – “An awesome tool… you can write docs, tests, and code all in one place” ￼.
	•	Use together: It’s worth noting that these tools can complement each other. For example, you might write a technical blog in Quarto (leveraging its websites), while using nbdev for the back-end Python code. Or use Quarto to render reports that use libraries you built with nbdev.

In summary, Quarto and nbdev both embrace notebooks, but for different goals. Quarto lets you publish beautiful documents from notebooks (slides, articles, or full websites) ￼ ￼. Nbdev lets you treat notebooks as the source of truth for Python code: you write functions in notebooks, then nbdev auto-generates modules, tests, and docs ￼ ￼. Together, they form a powerful literate-programming workflow: Quarto handles output formatting, and nbdev handles code structure, testing, and packaging.

Sources: Official Quarto documentation ￼ ￼ and nbdev guides/tutorials ￼ ￼ ￼ were used to summarize features, commands, and workflows. Experts have noted that nbdev+Quarto greatly streamlines development: “write notebooks with lightweight markup and get high-quality documentation, tests, continuous integration, and packaging for free” ￼. Common pitfalls (like mixing imports and code in one cell ￼ or not installing LaTeX for PDF) are highlighted above. Following these best practices and examples should help you get up and running smoothly with both tools.